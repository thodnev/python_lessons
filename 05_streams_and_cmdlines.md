## Потоки

У нас была команда типа
`cat 01_intro_environment.md | head -20 | tail -10 | sort`

Здесь мы передаем вывод одной программы на вход другой. Но что это значит?

1. Как ОС видит файлы и предоставляет их разным программам?
   У ОС есть интерфейс к userspace (пространство, где работают все программы). И в нем каждая программа видит файлы как handle. Т.е. есть какие-то числа, которые связаны с файлами. И когда программа использует число, она подразумевает файл.

   Посмотрим `man 2 open` — *2   System calls (functions provided by the kernel)*.

   `int open(...)`. `int` значит что она возвращает целое цисло (0, 1, 2, 3, ...)

   Другая функция (интерфейс для работы с файлами) - `man 2 write`. Там видим:
   
   `ssize_t write(int fd, ...)`

   `int fd` - значит, что функция, которая позволяет писать какие-то данные в файл, принимает аргументом какое-то целое число.

   *fd* - File Descriptor. Это и есть тот самый handle

   Мы открыли файл. ОС дала нам число для него, например, 5. Дальше все что мы хотим сделать для файла, мы используем с обращениями, указывая это число:
   *записать в 5 данные 'hello world'*.

2. Есть концепция, в \*nix "все есть файл". Это значит, что много интерфейсов системы доступны как файлы. В том числе, когда мы работаем с программой у нее есть 3 стандартных (уже открытых заранее) файла. Это стандартные потоки.

3. Какие бывают потоки (standard streams):
   - Ввод - `stdin` - индекс 0. Это все что мы вводим **в открытую программу**.
   - Вывод - `stdout` - индекс 1. Все что программа выводит в терминал (с помощью print-подобных функций), кроме ошибок.
   - Ошибки - `stderr` - индекс 2. Это поток такой же как stdout, но специально для ошибок.

   Надо разделять котлеты и мух: все ошибки должны идти в stderr. Их не надо печатать с помощью простого print в stdout.

   Это лучше, чем печатать ошибки просто `print`'ом.

    ```python
    print('File is unavailable', file=sys.stderr)
    ```


### Extras
- if-guards это конструкция
  `if __name__ == '__main__'`

  Когда мы выполняем код из модуля, магическая переменная `__name__` будет равна `'__main__'`.
  
  Когда мы его импортируем `__name__` будет равна имени импорта, т.е. `'greeter'` (но это может быть другим в других реализациях).
  
  Так мы можем определять, мы запускаем сам модуль или используем его как библиотеку.

  ```
  # python ./greeter.py
  DBG: my __name__ is __main__
  Hello, thd!
  ```

  ```
  import greeter
  DBG: my __name__ is greeter
  ```


#### Пример с потоками
Тут плохой скрипт уровня первого курса.

Обычно аргументы командной строки надо читать именно как аргументы (`sys.argv`), а не как строки стандартного вывода.

В нашем случае, тут действительно отдельные строки на стандартном выводе.
Но, вычитывая из него, в самой простой реализации скрипт выкидывает
много мусора в stdout:
```
[thd@mi educ]$ python ./demo.py
Enter name (END to end): Bob Ross
Enter name (END to end): John Doe
Enter name (END to end): Alice Young
Enter name (END to end): Bob Marley
Enter name (END to end): end
Alice Young
Bob Marley
Bob Ross
John Doe
```

Но уже тут можно применить работу с потоками.
Можно сделать файл. В него записать весь ввод:
```
Bob Ross
John Doe
Alice Young
Bob Marley
```

И теперь их можно ввести:
- Из stdout другой программы с помощью `|` (pipe):
  
  `cat demoinput.txt | python ./demo.py`
- Напрямую из файла:
  `python ./demo.py <demoinput.txt`
- Из других источников  ... (хоть из сокета)

А вывод скрипта я могу:
- Вывести на экран (дефолт)
- Положить в файл
  
  `cat demoinput.txt | python ./demo.py > sorted.txt`
- Передать другой программе (обрежет верхушку):
  
  `python ./demo.py <demoinput.txt | tail +2`
- Комплексно обработать:
  
  `python ./demo.py <demoinput.txt | tail +2 | sort -r > inv_sorted.txt`

Конструкция `>` пересоздаст файл и направит в него вывод.
А `>>` дополнит в конец файла выводом:
```
[thd@mi educ]$ echo one two >> sorted.txt
[thd@mi educ]$ cat sorted.txt 
Alice Young
Bob Marley
Bob Ross
John Doe
one two
[thd@mi educ]$ echo three four >> sorted.txt
[thd@mi educ]$ cat sorted.txt 
Alice Young
Bob Marley
Bob Ross
John Doe
one two
three four
```

Ошибки можно перенаправить в другой поток или в другой файл. Например тут сложим отдельно в лог ошибок:
```bash
python ./demo.py <demoinput.txt 2>errors.log >result.txt
```
Можно вообще проигнорить все ошибки, отправив их в магический blackhole-псевдофайл `/dev/null`.
Это такой (около)файл, который проглотит все данные, которые в него отправляются.

`python ./demo.py <demoinput.txt 2>/dev/null`

Выглядит как файл, но отбрасывает все направляемые в него данные, что успешно рапортуется ОС как нормальная запись.


`/dev/random` - псевдофайл, читая который, мы читаем рандомные значения, на лету генерируемые ОС.

`/dev/urandom` - -//- пошустрее

- Отправить один поток в другой:
  
  `python ./demo.py <demoinput.txt 2>&1 1>/dev/null`
  
  Выведет stderr -> stdout
  
  а stdout -> /dev/null

  Мы увидим только ошибки (как вывод), а сам вывод не увидим.


Пример ввода в stdin средствами Bash:
```
cat <<EOF | sort
> tatasdfa
> sdfas
> fw
> ew
> rdcv
> asdfadsf
> EOF
asdfadsf
ew
fw
rdcv
sdfas
tatasdfa
```