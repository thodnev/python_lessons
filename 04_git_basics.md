### Git Basics

- Более детально о `git log`:
  
  `git log` позволяет посмотреть историю коммитов. У него есть дельные опции:
  - `--oneline` чтоб вывести кратко только первую строку
  - `--graph` позволяет смотреть ветвление
  - `--decorate=short` чтобы референсы выводились кратко
  - `--show-signature` чтоб показывать подписи
  - `--all` чтоб показать все ветки, а не только текущую
- Есть GUI `gitk`. Для тяжелых случаев
- Хеш-суммы, по которым однозначно идентифицируются коммиты, можно сокращать:
  
  `0c9bee851709c28790b730f1d3916a2cf5760262`

  `0c9bee8`
  (по первым символам)

#### Продолжение о добавлении файлов в working tree с помощью `git add`

- Каждый файл класть под git с помощью
  `git add myfile myfile2 myfile3` неудобно.
  
  Поэтому, есть `git add .` – рекурсивный. Но если я просто сделаю `git add .` без файла
  `.gitignore` в репозитории, то он положит
  под git вообще все (включая ненужные файлы).
- `.gitignore` это файл, где числится все, что не должно попадать под git. Обычно это:
  - артефакты сборки
  - промежуточные файлы
    (например, директория `__pycache__`)
  - и т.д.

  Под git мы кладем **только то**, что нужно для сборки проекта (необходимый минимум).
  
  Например, документацию (как она написана, в виде исходников) можно класть, а собранные из нее PDF уже не стоит – это артефакты сборки.

- [Описание формата](https://git-scm.com/docs/gitignore) `.gitginore`
- У GitHub есть шаблоны стандартных `.gitignore` для разных языков. Например, 
[для Python](https://github.com/github/gitignore/blob/main/Python.gitignore).
Прямая ссылка для wget:
`https://raw.githubusercontent.com/github/gitignore/refs/heads/main/Python.gitignore`


Разберем его:
- `# Byte-compiled / optimized / DLL files` – комментарий.
- `__pycache__/`. `/` в конце – значит директории. Отсутствие `/` в начале – значит во всех директориях. Таким образом, эта строка означает: *не добавлять никакой директории `__pycache__` где бы она ни была.*
- `*.py[cod]` – значит любое имя файла в любой директории, которое заканчивается на:
`.pyc`, `.pyo` или `.pyd`.
`[cod]` это любой из символов в `[]`
- пустая строка игнорируется


Имеет смысл брать за основу готовый `.gitignore` в качестве шаблона и добавлять к нему все необходимое:

    # All PDFs in *current* directory
    /*.pdf
    # Script to convert MDs into PDFs
    /conv.sh

    # Directory testdir under repo root dir
    /testdir/

    # Byte-compiled / optimized / DLL files
    __pycache__/
    *.py[cod]
    *$py.class

- `.gitignore` может лежать и в субдиректориях. Он может расширять и дополнять правила верхних файлов `.gitignore`
- C помощью `!` (например, `!myfile`), можно отменять верхние правила

Теперь можем делать **`git add .`** или `git add -A`


#### Добавление изменений в текущий коммит

Допустим, мы что-то поменяли в последнюю секунду. И не успели выложить изменения на Git сервер.
Тогда можно не делать новый коммит, а добавить к предыдущему с помощью:

`git add .`

`git commit --amend` (откроет редактор сообщения коммита).

Или чтоб не открывать редактор, то

`git commit --amend --no-edit`

Им же можно редактировать описание коммита:

`git commit --amend -m "feat(repo): md description"`

или 
`git commit --amend`

**(!) НО** Он меняет коммит и историю. В случае, если коммит уже выложен в репозиторий и с ним могут работать другие люди, это плохо. Поскольку испортит их историю и синхронизацию репозитория.

Чтобы выложить (по-простому):
- `git remote add origin git@github.com:thodnev/python_lessons.git`
- `git push origin lessons`

Когда мы поменяли историю, может потребоваться forced push (плохо, но если вдумчиво, то можно): `git push -f`